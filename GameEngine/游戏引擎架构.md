# 游戏引擎架构

## Lesson1

### 现代游戏引擎架构的组成

**自上至下为**

工具层：可以直接在引擎中使用的工具

功能层：实现看得见，操作的了，各种各样的功能

资源层：存储和管理数据和资料（模型，音乐等）

核心层：提供更简单更基础的工具，如内存管理和图像变换

平台层：处理各种平台的输入，转化为统一输入

对第三方代码集成

### 引擎架构的挑战和要点

#### 资源的读取

为了去除无用信息和其他信息，对资源进行转换，到引擎高效数据Asset （为了在GPU中高效绘制，转换到dds格式后可以在GPU中成为纹理，高效计算）

定义一个asset**表示资源之间的关联**

**GUID**为每个asset设置，全局唯一资源识别号，可以识别唯一的资源文件

#### 资源的管理

handle系统，管理资源的生命周期

需要做好垃圾资源回收、延迟加载

#### 功能设计

在一个tick内完成一些的操作，离散的完成操作逻辑，使用视觉暂留达到连贯

##### Ticks

tickLogic() 对世界的模拟

tickRender() 对世界的渲染

先模拟再渲染

#### 多线程

使用多核处理多线程

#### 核心层

##### 数学逻辑

数学逻辑，线性代数

数学效率

SIMD 矩阵相乘

SSE

##### 数据结构和容器

重新做数据结构，使得高效访问

##### 内存管理

提供自行内存管理，追求高效

尽量提高数据局部性，尽量顺序访问，尽量批次删除

#### 平台层

通过一些操作，实现平台无关性，使得上层功能和平台无关

RHI 重新定义不同硬件API

#### 工具层

实现各种编辑器，通过工具层开发

##### 第三方数字资产

通过管线连接自己引擎和第三方工具

需要统一数据格式

#### 为什么需要分层

通过分层来只关注自己的信息，完成自己的工作

只能下层提供服务



## Lesson2

### 如何构建游戏世界

#### 游戏世界的拆解

大多数东西都可以抽象成Game Object（GO）

##### 动态物 Dynamic Game Object

##### 静态物 Static Game Object

##### 地形、天空、植被 Environment

##### 其他物

如检测体（空气墙等）

###### Example 描述无人机

属性：外形、油量等

行为：移动等

#### 如何定义对象

可以通过面向对象来编程

组件化定义，**把同一个基础变成各种各样的东西**

把所有东西抽象成GO，GO可以被定义为多个组件的组合

#### Tick

通过tick来传递动作和改变，使得物品动起来

现代引擎中对每个系统进行tick，而不是GO，原因是不够高效，不够流水线

#### GO间交互

hardcore很难实现

##### 事件机制

通过事件通知，下个tick时GO进行检测受到的事件信息，进行对应的改变，实现解耦合（观察者模式）

通过消息系统，使得开发者可以获取定制的信息类型

##### 管理场景，通知GO

对每一个游戏实体赋予唯一ID，以及GO的位置

如果不管理，就要对每一个其他物体全部互动，会得到O($n^2$)的复杂度

###### 解决方法

1、通过画网格解决，寻找临近格子判断

2、层级管理（四叉树），通过不断划分到四个区域，只需要在四个节点中寻找

3、八叉树

4、BVH

等

#### 物体绑定

当两个物体绑定，被绑定的物体一般先tick

##### tick的先后顺序

在并行执行的tick中，可能会出现悖论，可能会在相同输入导致不同结果

pretick和posttick可以解决时序问题

对于过长的tick，跳过一个tick（危险），或者补偿步长，或者分批次处理

tick逻辑线程一般比tick render线程早一些

空间划分时更新游戏对象，使用BVH或BSP

组件模式效率会低一点

先播放动画，再物理模拟



## Lesson3 绘制系统

Rendering system

#### 渲染的挑战

大量的物体之间的组合

必须深度适配当代硬件

交付一个合理的清晰度和帧率

合理的占用CPU带宽和内存访问

### 渲染系统

#### 基于硬件的游戏渲染

通过投影、光栅化、材质着色得到

投影+光栅化+着色

通过计算各自参数使得贴图的融合等得到想要的颜色和结果

##### 材质采样

材质的观测可能在不同距离不同，造成摩尔纹或者锯齿

##### 显卡

SIMD单指令多数据同时加减

SIMT单指令多线程。在一条指令中用多个小核计算

GPC图形处理集群：复杂数学运算，光栅化，着色，材质

##### 数据流动成本

尽可能单向传输数据，不要从显卡读数据

##### 注意缓存友好性

利用数据并行性

避免不命中

##### 术语

ALU bounds 数学计算太多导致需要等待

引擎架构需要和渲染架构密切相关

#### 可绘制对象

逻辑表达和绘制是不同的

##### Mesh Primitive

永远很多的顶点数据，顶点的法向朝向、位置，颜色

##### Index data 和 Vertex data

只存三角形顶点的索引值，因为很多顶点可以共用

<img src="C:\Users\ARK_LIU\AppData\Roaming\Typora\typora-user-images\image-20221025150828380.png" alt="image-20221025150828380" style="zoom:50%;" />

定义顶点数据时要单独定义法线方向

##### 材质

绘制材质和物理材质

纹理是材质的一种

##### Shader

![image-20221025160543785](C:\Users\ARK_LIU\AppData\Roaming\Typora\typora-user-images\image-20221025160543785.png)